---
layout: post
title: Docker 이미지와 컨테이너
date: 2024-07-17
categories: [Docker]
tags: [Docker]
---

## Docker 이미지와 컨테이너

도커로 작업을 한다면, 이미지와 컨테이너를 필연젹으로 사용하게 된다.

따라서 도커를 배우고 사용하려면 먼저 이미지와 컨테이너에 대한 내용을 이해하고 사용할 줄 알아야 한다.

### 컨테이너

컨테이너는 애플리케이션, 웹사이트, 노드 서버, 애플리케이션을 실행하는 전체 환경 등, 무엇이든 포함하는 작은 패키지이다

즉, 컨테이너에 소프트웨어 실행 유닛이 존재한다.

결국 그 유닛을 우리가 실행하는 것이다.

### 이미지

이미지는 컨테이너를 만들기 위한 템플릿, 블루프린트이다.

이미지는 실제로 코드와 코드를 실행하는데 필요한 도구를 포함한다.

즉, 도커는 이미지를 기반으로 하는 컨테이너를 실행하는 것이다.

1. 이미지 생성 (또는 다운로드)
2. 이미지를 사용하여 컨테이너 생성 및 실행

이렇게 이미지와 컨테이너를 구분함으로써, 이미지를 한 번만 만들어 놓으면 다른 시스템과 다른 서버에서 여러번 사용할 수 있게 된다.

![image](/assets/img/2024-07-16-Docker%20이미지와%20컨테이너/2024-07-16-11-56-32.png)

즉, 도커 컨테이너 실행 시 이미지가 필수적으로 필요한데, 이미지를 구하는 방법은 두 가지가 있다.

1. 이미 존재하는 이미지를 다운로드하여 사용
2. 이미지를 직접 빌드하여 사용

## 이미 존재하는 이미지를 다운로드하여 사용

이미 많은 이미지들을 온라인에서 구할 수 있는데, 대표적인 이미지 저장소는 [Docker Hub](https://hub.docker.com/)이다.

이 도커허브에서 원하는 이미지를 검색 및 다운로드하여 사용할 수 있다.

이미지를 다운로드할 때는 `docker pull` 명령어를 사용한다.

```bash
docker pull <이미지 이름>
```

예를 들어 우분투 이미지를 다운로드 할 경우 다음과 같이 명령어를 사용한다.

```bash
docker pull ubuntu
```

이렇게 이미지를 다운로드하면, 다음과 같이 이미지 목록을 확인할 수 있다.

```bash
docker images
```

```plaintext
REPOSITORY                TAG         IMAGE ID      CREATED      SIZE
docker.io/library/ubuntu  latest      ffb64c9b7e8b  5 weeks ago  103 MB
```

위 이미지를 실행하려면 다음과 같이 명령어를 사용한다.

```bash
docker run ubuntu
```

위 명령어를 실행하면 이미지가 실행된다. 하지만 실행된 이미지는 아무런 작업을 하지 않고 곧바로 종료된다. 그렇기 때문에 마치 실행이 되지 않은 것처럼 보일 수 있다.

실행되었는지 확인하려면 `docker ps -a` 명령어를 사용한다. (docker ps 명령어는 실행중인 컨테이너만 보여주기 때문에 `-a` 옵션을 사용한다.)

```bash
docker ps -a
```

```plaintext
CONTAINER ID  IMAGE                            COMMAND     CREATED        STATUS                    PORTS       NAMES
c20ada9422a5  docker.io/library/ubuntu:latest  /bin/bash   2 seconds ago  Exited (0) 2 seconds ago              adoring_neumann
```

위와 같이 컨테이너가 생성되었고, 종료된 것을 확인할 수 있다. 그렇다면 왜 컨테이너가 바로 종료되었을까?

도커 컨테이너는 기본적으로 Foreground 모드상태다. 그러나 우분투 실행하면서 아무런 작업을 하지 않았기 때문에 컨테이너가 바로 종료된 것이다.

만약 컨테이너 실행 시 명령을 추가하고 싶다면, `docker run` 명령어 뒤에 명령어를 추가하면 된다.

```bash
docker run <이미지 이름> <명령어>
```

예를 들어 현재 시간을 출력하는 명령어를 추가하고 싶다면 다음과 같이 명령어를 사용한다.

```bash
docker run ubuntu date
```

```plaintext
Tue Jul 16 04:36:32 UTC 2024
```

위와 같이 현재 시간이 출력된 것을 확인할 수 있다. 이번에도 물론 명령을 끝마친 후 컨테이너는 종료된다.

이번에는 컨테이너가 종료되지 않고 계속 실행되도록 하려면 `-it` 옵션을 사용한다.

```bash
docker run -it ubuntu
```

위 명령어를 실행하면 컨테이너가 실행되고, 컨테이너 내부로 들어가게 된다. 그리고 일반적인 우분투 터미널을 사용할 수 있다.

```bash
root@7be2ccdde46d:/# date
```

```plaintext
Tue Jul 16 04:36:32 UTC 2024
```

그렇다면 `-it` 옵션은 무엇이며 왜 사용하는 것일까?

일반적으로 컨테이너 실행 시의 쉘은 외부로 노출되지 않는다. 따라서 외부에서 명령을 실행할 수 없는 상태이다. 인터렉티브 쉘을 노출시키려면 `-it` 옵션을 사용한다. 이 때 각 옵션의 의미는 다음과 같다.

- `-i` : 컨테이너와 상호작용을 가능하게 한다. 즉, 컨테이너와 터미널을 연결한다.
- `-t` : 가상 터미널을 할당한다. 즉, 터미널을 사용할 수 있게 한다.

따라서 `-it` 옵션을 통해 컨테이너 내부에서 호스팅 머신으로 대화형 세션을 노출하고 싶다고 알린다.

실행중인 프로세스를 종료하려면 `exit` 명령어를 사용한다.

```bash
exit
```

## 이미지를 직접 빌드하여 사용

### 이미지를 직접 빌드하는 이유

만약 완성된 서비스를 사용할 뿐이라면 이미지를 다운로드하여 사용하는 것으로 충분하다.

하지만 자신만의 기능을 추가하는 등의 커스터마이징을 하고 싶다면 얘기가 달라진다.

위의 예시처럼 우분투 컨테이너 위에 여러 서비스를 설치할 수도 있지만, 매번 컨테이너를 실행할 때 마다 대화형 셸을 사용해서 명령을 실행하는 번거로움이 발생한다.

예를 들어 Nginx를 통한 웹 서버를 만든다고 가정하자. 우분투 컨테이너를 실행하고 웹 서버를 설치하고 실행하는 과정을 모두 수동으로 진행해야 한고 컨테이너를 실행할 때 마다 이 과정을 반복해야 한다.

1. 우분투 컨테이너 실행 및 대화형 셸로 접속
2. `apt-get update` 명령어를 실행하여 패키지를 업데이트
3. `apt-get install -y nginx` 명령어를 실행하여 Nginx를 설치
4. `nginx -g 'daemon off;'` 명령어를 실행하여 Nginx를 실행

이런 번거로움을 해결하기 위해 이미지를 직접 빌드하여 사용하는 것이다.

### 이미지를 직접 빌드하는 방법

도커는 새로운 이미지를 만들기 위해 `Dockerfile`이라는 파일을 사용한다. (`Dockerfile`은 도커에 의해 식별되는 특별한 이름이다.) `Dockerfile`을 새로 만들고, 다음과 같은 내용을 추가한다.

```Dockerfile
FROM ubuntu
RUN apt-get update
RUN apt-get install -y nginx
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

눈썰미가 좋다면 위 내용이 이전에 우분투 컨테이너를 실행하고 Nginx를 설치하고 실행하는 과정과 동일하다는 것을 알 수 있다.

각 내용을 설명하면 다음과 같다.

- `FROM ubuntu` : 우분투 이미지를 기반으로 새로운 이미지를 만들겠다는 의미이다.
- `RUN apt-get update` : 패키지를 업데이트한다. 셸에서 `apt-get update` 명령어를 실행하는 것과 동일하다.
- `RUN apt-get install -y nginx` : Nginx를 설치한다. 셸에서 `apt-get install -y nginx` 명령어를 실행하는 것과 동일하다.
- `EXPOSE 80` : 80번 포트를 외부에 노출한다. 즉, 호스트와 컨테이너 간의 포트 연결을 설정한다.
- `CMD ["nginx", "-g", "daemon off;"]` : Nginx를 실행한다. 셸에서 `nginx -g 'daemon off;'` 명령어를 실행하는 것과 동일하다.
  - `RUN` 과 `CMD`의 차이점은 `RUN`은 이미지를 빌드할 때 실행되는 명령어이고, `CMD`는 컨테이너가 시작될 때 실행되는 명령어이다.

도커는 이 이미지를 만들기 위한 명령어들을 포함하고 있는 이 `Dockerfile`을 이용하여 이미지를 빌드한다. 도커는 `docker build` 명령어를 사용하여 이미지를 빌드한다.

```bash
docker build -t <이미지 이름> <Dockerfile 경로>
```

예를 들어 `nginx` 이미지를 빌드할 경우 다음과 같이 명령어를 사용한다. (명령어 수행 전 경로를 잘 확인하자)

```bash
docker build -t my-nginx .
```

위 명령어를 실행하면 `my-nginx`라는 이미지가 생성된다. 이미지를 확인하려면 `docker images` 명령어를 사용한다.

```bash
docker images
```

```plaintext
REPOSITORY                 TAG         IMAGE ID      CREATED         SIZE
localhost/my-nginx         latest      b245785e1bfe  51 seconds ago  151 MB
```

이렇게 이미지가 생성된 것을 확인할 수 있다. 이렇게 생성된 이미지에는 nginx가 설치되어 있고, 80번 포트가 노출되어 있다. 그렇도록 `Dockefile`에 명시했기 때문이다.

이미지를 만들었으니 이제 이 이미지를 사용하여 컨테이너를 실행할 수 있다.

```bash
docker run my-nginx
```

위 명령어로 컨테이너를 실행하면 이제 `Dockerfile`에 명시한 내용대로 `nginx -g 'daemon off;'` 명령어가 실행되어 nginx 서버가 실행된다.

하지만 localhost로 접속하면 접속이 되지 않는다. 분명히 `Dockerfile`에 `EXPOSE 80`을 명시하여 80번 포트를 노출했는데도 접속이 되지 않는다. 확인을 위해 새로운 터미널을 열어 `docker ps` 명령어를 사용하여 컨테이너의 상태를 보자.

```bash
docker ps
```

```plaintext
CONTAINER ID  IMAGE                      COMMAND               CREATED        STATUS        PORTS       NAMES
1f629038b1c2  localhost/my-nginx:latest  nginx -g daemon o...  4 seconds ago  Up 4 seconds  80/tcp      exciting_moser
```

위 내용에서도 보듯 `80/tcp` 포트가 노출되어 있음을 확인할 수 있다. 그렇다면 왜 접속이 되지 않을까?

`Dockerfile`의 `EXPOSE 80`이 있지만 사실상 이 명령은 아무것도 하지 않는다. `EXPOSE` 명령은 컨테이너가 어떤 포트를 사용할 것인지 알려주기 위한 역할일 뿐, 실제로 포트를 열지는 않는다. 순수하게 문서화를 위한 목적이다. 문서화를 위해 `EXPOSE`를 추가하는 것은 모범적인 사례이고, 분명 이를 추가하여 컨테이너 포트를 노출시켜야 하지만 해당 내용이 없어도 정상작동 할 것이다.

진정으로 포트를 노출시키려면 `docker run` 명령어를 사용할 때 `-p` 옵션을 사용한다. `-p` 옵션은 호스트와 컨테이너의 포트를 연결하겠다는 의미이다. 이를 통해 로컬 머신의 어떤 포트가 이 내부의 도커 특정 포트에 액세스 할 수 있는지를 지정할 수 있다.

```bash
docker run -p 8080:80 my-nginx
```

위 명령어를 실행하면 로컬 머신의 8080번 포트를 컨테이너의 80번 포트에 연결한다. 이제 브라우저에서 `localhost:8080`으로 접속하면, Docker의 Nginx 서버에 접속할 수 있다.

![image](/assets/img/2024-07-16-Docker%20이미지와%20컨테이너/2024-07-17-12-11-55.png)

이렇게 자신만의 이미지를 만들어 컨테이너를 실행할 수 있다. 다양한 `Dockerfile` 명령어를 사용하여 이미지에 코드나 바이너리 파일, 라이브러리, 환경 변수 등을 추가할 수도 있다. 이를 통해 자신만의 이미지를 만들어 사용할 수 있다.

이제 실행중인 컨테이너를 종료해보자. 컨테이너를 종료하려면 `docker stop` 명령어를 사용한다.

```bash
docker stop <컨테이너 ID>
```

컨테이너 ID는 `docker ps` 명령어를 사용하여 확인할 수 있다. (커스텀 네임을 지정하는 방법도 있지만 나중에 알아보자)
