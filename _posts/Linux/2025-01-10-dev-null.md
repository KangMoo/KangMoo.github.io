---
layout: post
title: Linux 백그라운드 실행
date: 2025-1-10
categories: [Linux]
tags: [Linux, /dev/null]
summary: 
---

## 백그라운드 실행 : `nohup [명령어] > /dev/null 2>&1 &`

프로세스를 백그라운드 실행 시, 명령어 뒤에 다음과 같은 내용을 붙인다.

`nohup [명령어] > /dev/null 2>&1 &`

이 명령어를 설명하면 다음과 같다.

1. `nohup` : 터미널 세션이 종료되어도 프로세스가 계속 실행하도록 보장
2. `>` : 표준 출력을 지정된 파일로 리다이렉트
3. `/dev/null` : 출력을 버리는 특수한 파일
4. `2>&1` : 표준 에러를 표준 출력과 같은 곳으로 리다이렉트
5. `&` : 백그라운드 실행

각 명령어에 대해 자세히 설명하면 다음과 같다.

### `nohup`

`nohup`은 터미널 세션이 종료되어도 프로세스가 계속 실행하도록 보장하는 명령으로, **SIGHUP 신호(터미널 세션 종료 시 발송되는 신호)를 무시**하도록 설정한다. 따라서 터미널 세션이 종료되어도 프로세스가 중단되지 않고 계속 실행된다.

출력(`stdout`/`stderr`)은 기본적으로 `nohup.out` 파일로 저장되며, 리다이렉트를 통해 별도로 지정할 수 있다.

### `>`

`>`는 표준 출력(`stdout`)을 지정된 파일로 리다이렉트 하는 명령어이다.

즉, 출력의 결과를 특정 파일에 쓰겠다는 의미다

예를 들어 다음과 같은 명령어가 있다고 하자

```bash
echo "Hello World" > hello.txt
```

`echo "Hello World"` 명령어는 `Hello World`를 출력한다. 이 출력을 `hello.txt` 파일에 쓰겠다는 의미다.

명령어를 수행하고 나면 `hello.txt` 파일에 `Hello World`가 쓰여져 있는 것을 확인할 수 있다.

### `/dev/null`

`/dev/null`은 리눅스에서 데이터를 버리는 특수한 파일이다.

이 파일은 쓰기 시 데이터를 즉시 폐기하며, 읽기 시에는 EOF(End of File)를 반환한다.

이 파일에 데이터를 쓰면, 데이터는 사라진다. 즉, 데이터를 **버리는** 용도로 사용될 수 있다.

예를 들어 다음과 같은 명령어가 있다고 하자

```bash
echo "Hello World" > /dev/null
```

위에서 설명한 리다이렉트(`>`)에 따라 `echo "Hello World"`의 출력을 `/dev/null`에 쓰려고 하지만, `/dev/null`은 데이터를 버리는 용도로 사용되기 때문에, `echo "Hello World"`의 출력은 사라진다.

### `2>&1`

`2>&1`은 표준 에러(`stderr`)를 표준 출력(`stdout`)과 동일한 대상으로 리다이렉트하라는 의미다. (리눅스에서 1은 표준 출력(`stdout`)을 의미하고, 2는 표준 에러(`stderr`)를 의미한다.)

따라서 `> /dev/null 2>&1`은 다음 순서로 동작한다

1. 표준 출력을 `/dev/null`로 리다이렉트하여 모든 출력물을 버린다.
2. 표준 에러를 표준 출력과 동일한 대상으로 리다이렉트하므로, 표준 에러 역시 `/dev/null`로 리다이렉트된다.

따라서 명령어 특정 명령어 뒤에 `> /dev/null 2>&1`을 붙이면, 출력 결과와 에러를 모두 무시하고 실행한다.

보통 디버깅이 필요없는 상황에서 불필요한 출력을 줄이는데 사용된다.

### `&`

`&`는 명령을 백그라운드에서 실행하도록 지시한다. 이를 통해 터미널은 명령 실행을 기다리지 않고 즉시 프롬프트를 반환한다.

또한 명령은 새로운 서브셸에서 실행되므로, 독립적으로 실행될 수 있다. 명령 실행 후, 작업 번호(`job number`)와 프로세스 ID(`PID`)가 출력된다.

예를 들어 `sleep 10` 명령어는 10초 동안 대기하라는 명령으로, 실행하면 10초 뒤에 프롬프트가 반환되고, 다음 명령을 입력할 수 있다.

하지만 `sleep 10 &` 명령어는 10초 동안 대기하라는 명령을 백그라운드에서 실행하라는 의미로, 명령을 실행하자마자 프롬프트가 반환되고, 다음 명령을 입력할 수 있다.

따라서 보통 여러 작업을 동시에 실행하거나 시간이 오래 걸리는 작업을 처리할 때 `&`를 사용하여 백그라운드로 실행시키고, 사용자는 다른 작업을 수행할 수 있게 된다.

## 포어그라운드 에서 백그라운드로 전환

이미 실행 중인 포어그라운드 프로세스를 백그라운드로 전환할 수도 있다. 이를 위해서는 다음 단계를 따른다.

1. `Ctrl + Z` : 프로세스 일시 중지
2. `bg` : 프로세스를 백그라운드로 전환
3. `disown` : 프로세스 독립 실행

### `Ctrl + Z`

`Ctrl + Z`는 현재 실행 중인 포어그라운드 프로세스에 `TSTP` 신호를 보내어, 해당 프로세스를 일시 중지 상태로 전환하는 단축키다.

`Ctrl + Z`는 현재 실행 중인 프로세스를 일시 중지 상태(`Stopped`)로 전환하는 단축키다.

예를 들어, `sleep 100` 명령어를 실행 중이라고 가정하자.

```bash
sleep 100
```

이 명령어를 실행하면 터미널이 100초 동안 대기 상태가 된다. 이 상태에서 `Ctrl + Z`를 누르면 프로세스가 **일시 중지**된다. (프로세스를 다시 실행하려면 `fg` 명령어를 입력하면 된다.)

```bash
[1]+  Stopped                 sleep 100
```

### `bg`

`bg`는 일시 중지된 프로세스를 백그라운드에서 재개하는 명령어다.

`bg %작업번호` 형식으로 사용하며, 작업 번호는 `jobs` 명령어를 통해 확인할 수 있다.

```bash
jobs
[1]+  Stopped                 sleep 100
```

`jobs` 명령어로 작업번호를 확인하면 `1`이라는 작업번호를 확인할 수 있다. 따라서 `bg %1` 명령어를 입력하여 프로세스를 백그라운드로 전환할 수 있다.

```bash
bg %1
[1]+ sleep 100 &
```

만약 작업번호 없이 `bg` 명령어만 입력하면, 마지막으로 정지된 프로세스가 기본적으로 대상이 된다.

앞선 명령어(`Ctrl + Z`)로 프로세스를 일시 중지한 후, `bg` 명령어를 입력하여 프로세스를 백그라운드로 전환한다.

```bash
bg
[1]+ sleep 100 &
```

이제 `sleep 100` 명령어는 백그라운드에서 실행되며, 터미널은 즉시 프롬프트를 반환하여 다른 명령을 입력할 수 있게 된다.

### `disown`

`disown`은 프로세스를 셸 세션으로부터 완전히 독립시키는 명령어다. 이를 통해 세션이 종료되더라도 해당 프로세스는 계속 실행된다. 기본적으로 `disown`은 백그라운드에서 실행 중인 프로세스에 대해 사용되며, 특정 작업 번호를 지정할 수도 있다.

`Ctrl + Z`로 프로세스를 일시 중지하고, `bg`로 프로세스를 백그라운드로 전환하면, 프로세스는 백그라운드에서 실행되지만, 세션이 종료되면 프로세스도 종료된다. 이를 방지하기 위해 `disown` 명령어를 입력하여 프로세스를 독립 실행시킨다.

`disown %작업번호` 형식으로 사용하며, 작업 번호는 `jobs` 명령어를 통해 확인할 수 있다. (작업 번호를 지정하지 않으면 마지막으로 백그라운드로 전환된 프로세스가 대상이 된다.)

```bash
disown %1
```
